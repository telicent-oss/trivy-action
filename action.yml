name: Trivy Scan Action
description: |
  This action scans a filesystem/SBOM/Container Image using Trivy
author: Telicent
branding:
  icon: 'lock'
  color: 'green'
inputs:
  scan-ref:
    required: true
    description: |
      The reference to the filesytem path, SBOM file, or container image to scan
  scan-name:
    required: true
    description: |
      A unique name for the scan to disambiguate the Job Artifacts it creates from 
      others created by the same workflow.

      Note that the given `scan-name` value will be sanitised to remove characters that are 
      not permitted by the actions that consume this value.  You can find the actual names
      used for the report files and artifacts in the action output.
  scan-type:
    required: true
    description: |
      Specifies the kind of Trivy scan to perform, one of `image`, `fs` or `sbom`.  Other
      values are not currently supported and will cause the action to fail.
  remote-vex:
    required: false
    default: ""
    description: |
      Specifies a new line separated list of remote repositories whose VEX statements should be
      retrieved via sparse checkout of their .vex/ directory.  These VEX statements will be used 
      to augment any local VEX statements in the .vex/ directory when scanning for vulnerabilities.
  gh-token:
    required: false
    default: ${{ github.token }}
    description: |
      A GitHub Token needed to determine the current Trivy database version for caching.
      Defaults to `github.token` which is the token for this build, can be overridden if this default token doesn't work
      for your build environment.
  gh-user:
    required: false
    default: ${{ github.actor }}
    description: |
      A GitHub User to use when cloning remote repositories to retrieve remote VEX statements.

      Defaults to `github.actor` which is the user running the build, can be overridden if this default user does not 
      match the user who owns the `gh-token` input e.g. if providing a custom GitHub Token to retrieve VEX statements
      from private repositories.
  uses-java:
    required: false
    default: "false"
    description: |
      Indicates whether the scan needs the Trivy Java Database available.
  allow-unfixed:
    required: false
    default: "false"
    description: |
      Specifies whether it is permitted for the action to pass if it detects High/Critical 
      vulnerabilities that do not currently have a fix i.e. there is not necessarily anything
      we could do to resolve them at this time.
outputs:
  scan-results:
    value: ${{ steps.generate-outputs.outputs.scan-results }}
    description: |
      The name of a GitHub Actions Artifact that has been uploaded by this action and contains 
      the full Trivy JSON scan results generated by the Trivy scan.
  scan-results-file:
    value: ${{ steps.generate-outputs.outputs.scan-results-file }}
    description: |
      The name of the Trivy JSON results file contained in the uploaded GitHub Actions artifact.
  scan-results-url:
    value: ${{ steps.generate-outputs.outputs.scan-results-url }}
    description: |
      The URL of the GitHub Actions Artifact that has been uploaded by this action and contains 
      the full Trivy JSON scan results generated by the Trivy Scan.
runs:
  using: "composite"
  steps:
    - name: Fail on Unsupported Scan Type
      # NB - Can't have an array literal directly in an Actions expression, but can use fromJSON() function 
      #      to parse an array literal on the fly, go figure!
      #      See https://github.com/orgs/community/discussions/27223
      if: ${{ !contains(fromJSON('[ "image", "fs", "sbom", "config" ]'), inputs.scan-type) }}
      shell: sh
      run: |
        echo "::error title=${{ github.job }} - Unsupported Scan Type::Received Scan Type '${{ inputs.scan-type}}' which is not supported"
        exit 1

    # As we're going to use the scan name for both output file names and GitHub Actions Artifacts have to sanitise it
    # to remove characters that are disallowed, or would cause those usages to break
    #
    # For GitHub Actions Artifacts this is as follows:
    # 
    # Double quote ", Colon :, Less than <, Greater than >, Vertical bar |, Asterisk *, Question mark ?, Carriage 
    # return \r, Line feed \n, Backslash \, Forward slash /
    #
    # These characters are not allowed in the artifact name due to limitations with certain file systems such as NTFS. 
    # To maintain file system agnostic behavior, these characters are intentionally not allowed to prevent potential 
    # problems with downloads on different file systems.

    - name: Sanitise Scan name
      id: sanitised
      shell: bash
      run: |
        echo "name=$(echo '${{ inputs.scan-name }}' | sed 's/[:/<>|*?\]/-/g' | tr -s '-')" >> $GITHUB_OUTPUT

    - name: Setup Trivy
      uses: aquasecurity/setup-trivy@v0.2.2
      with:
        version: v0.60.0
        cache: true

    - name: Trivy Cache
      id: trivy-cache
      uses: yogeshlonkar/trivy-cache-action@3eda36a23c102481fd8813f03eae09a91f2e8fab
      with:
        gh-token: ${{ inputs.gh-token }}
        prefix: ${{ github.workflow }}-${{ inputs.uses-java == 'true' && 'java' || 'no-java' }}

    - name: Download Trivy Java DB
      if: ${{ inputs.uses-java == 'true' && (steps.trivy-cache.outputs.cache-hit == '' || steps.trivy-cache.outputs.cache-hit == 'false') }}
      #uses: aquasecurity/trivy-action@0.30.0
      uses: rvesse/trivy-action@fix/overwrite-envs
      env:
        TRIVY_DOWNLOAD_JAVA_DB_ONLY: true
        TRIVY_JAVA_DB_REPOSITORY: public.ecr.aws/aquasecurity/trivy-java-db,ghcr.io/aquasecurity/trivy-java-db:1
      with:
        scan-type: image
        timeout: 10m0s
        cache-dir: .trivy
        # We've explicitly called aquasecurity/setup-trivy already, no need for the trivy-action to do this for us
        skip-setup-trivy: true
        # Counter-intuitive BUT trivy-action has its own cache behaviour which duplicates our own but in a less 
        # flexible way
        cache: false

    - name: Download Trivy Vulnerability DB
      if: ${{ steps.trivy-cache.outputs.cache-hit == '' || steps.trivy-cache.outputs.cache-hit == 'false' }}
      #uses: aquasecurity/trivy-action@0.30.0
      uses: rvesse/trivy-action@fix/overwrite-envs
      env:
        TRIVY_DOWNLOAD_DB_ONLY: true
        TRIVY_DB_REPOSITORY: public.ecr.aws/aquasecurity/trivy-db,ghcr.io/aquasecurity/trivy-db:2
      with:
        scan-type: image
        timeout: 10m0s
        cache-dir: .trivy
        # We've explicitly called aquasecurity/setup-trivy already, no need for the trivy-action to do this for us
        skip-setup-trivy: true
        # Counter-intuitive BUT trivy-action has its own cache behaviour which duplicates our own but in a less 
        # flexible way
        cache: false

    - name: Setup vexctl
      uses: openvex/setup-vexctl@main
      with:
        vexctl-release: '0.3.0'

    - name: Download Remote VEX Statements
      if: ${{ inputs.remote-vex != '' }}
      shell: bash
      run: |
        mkdir .remote-vex
        pushd .remote-vex
        git init -b main
        git config core.sparseCheckout true
        echo ".vex/*" > .git/info/sparse-checkout
        for REPO in $(echo "${{ inputs.remote-vex }}"); do
          # Check for non-empty repository
          REPO=$(echo "${REPO}" | tr -d '[:space:]')
          if [ -z "${REPO}" ]; then
            continue
          fi

          # Determine branch, defaulting to main
          BRANCH=${REPO##*@}
          if [ "${REPO}" == "${BRANCH}" ]; then
            BRANCH=main
          else
            REPO=${REPO%%@*}
          fi

          # Actually retrieve remote VEX statements
          # If a remote reference can't be retrieved then we simply log that
          # If a remote reference is valid but contains no remote VEX statements then we issue a warning
          echo "Retrieving Remote VEX statements from ${BRANCH} branch of ${REPO}"
          git remote add -f origin https://${{ inputs.gh-user }}:${{ inputs.gh-token }}@github.com/${REPO} || echo "Failed to fetch remote repository ${REPO}"
          git checkout --force ${BRANCH} || echo "Failed to checkout branch ${BRANCH} from remote repository ${REPO}"
          if [ -d ".vex/" ]; then
            mv -fv .vex/*.json . || echo "No remote VEX statements found, they MUST have a .json extension and be in the .vex/ directory of the remote repository"
            rm -Rf .vex/
          else
            echo "::warning title=No Remote VEX Statements in ${REPO}::Repository ${REPO} did not contain a .vex/ directory on its ${BRANCH} branch"
          fi
          git remote remove origin || echo "No remote origin to remove"
        done

        echo "Found the following Remote VEX Statements:"
        ls -lh *.json || echo "No Remote VEX Statements found"

        popd

    # For convenience as there may be many VEX statements present merge them into a single VEX file that we then
    # pass into Trivy by setting the TRIVY_VEX environment variable
    # This also serves to validate that all the VEX statements are well-formed as this will fail if they are not
    - name: Prepare VEX Statements
      id: prepare-vex
      shell: bash
      run: |
        # If local VEX statements exist merge them together
        if [ -d ".vex/" ]; then
          vexctl merge .vex/*.json > merged.raw.openvex.json || rm merged.raw.openvex.json
        fi
        # If any remote VEX statements exist merge them together as well
        if [ -d ".remote-vex/" ]; then
          vexctl merge .remote-vex/*.json > merged.remote.openvex.json || rm merged.remote.openvex.json
        fi

        # If both local and remote VEX statements exist merge them together into a final
        # merged file
        # Or if only remote VEX statements exist rename that file, otherwise the next if block
        # where we set TRIVY_VEX won't be triggered
        if [ -f merged.raw.openvex.json ] && [ -f merged.remote.openvex.json ]; then
          mv merged.openvex.json merged.local.openvex.json
          vexctl merge merged.local.openvex.json merged.remote.openvex.json > merged.raw.openvex.json
        elif [ -f merged.remote.openvex.json ]; then
          mv merged.remote.openvex.json merged.raw.openvex.json
        fi

        # Deduplicate entries
        if [ -f merged.raw.openvex.json ]; then
          jq '. | .statements |= (unique_by(.vulnerability.name + "-" + (.products | map(.["@id"]) | join(",")))) ' merged.raw.openvex.json > merged.openvex.json 
          rm merged.raw.openvex.json
        fi

        # Export the TRIVY_VEX environment variable if we have VEX statements available
        # We also rename the file at this point to be more descriptive
        if [ -f merged.openvex.json ]; then
          mv merged.openvex.json ${{ steps.sanitised.outputs.name }}-merged.openvex.json
          echo "TRIVY_VEX=${{ steps.sanitised.outputs.name }}-merged.openvex.json" >> $GITHUB_ENV
          echo "prepared=true" >> $GITHUB_OUTPUT
        else
          echo "prepared=false" >> $GITHUB_OUTPUT
        fi

    - name: Upload VEX Statements (if any)
      if: ${{ steps.prepare-vex.outputs.prepared == 'true' }}
      uses: actions/upload-artifact@v4.4.3
      with:
        name: ${{ steps.sanitised.outputs.name }}-merged-vex-statements
        path: ${{ steps.sanitised.outputs.name }}-merged.openvex.json
        retention-days: 30

    # Perform a full vulnerability to generate a full vulnerability report
    - name: Trivy Vulnerability Scan
      #uses: aquasecurity/trivy-action@0.30.0
      uses: rvesse/trivy-action@fix/overwrite-envs
      env:
        TRIVY_SKIP_DB_UPDATE: true
        TRIVY_SKIP_JAVA_DB_UPDATE: true
        # This ensures that anything suppressed by VEX statements (if any) is noted in the Trivy JSON Report
        TRIVY_SHOW_SUPPRESSED: true
      with:
        scan-type: ${{ inputs.scan-type }}
        output: ${{ steps.sanitised.outputs.name }}-trivy-report.json
        format: json
        scan-ref: ${{ inputs.scan-ref }}
        # This means even if high severity vulnerabilities are found we'll continue onwards
        # This is intended as we have a later step that scans just for HIGH/CRITICAL and sets this to 1
        #Â meaning the action as a whole fails if high severity vulnerabilities are found
        # But for this step we're just looking to generate a report of all vulnerabilities
        exit-code: 0
        cache-dir: .trivy
        # We've explicitly called aquasecurity/setup-trivy already, no need for the trivy-action to do this for us
        skip-setup-trivy: true
        # Counter-intuitive BUT trivy-action has its own cache behaviour which duplicates our own but in a less 
        # flexible way
        cache: false

    - name: Upload Vulnerability Scan Results
      id: upload-scan-results
      uses: actions/upload-artifact@v4.4.3
      with:
        name: ${{ steps.sanitised.outputs.name }}-trivy-report
        path: ${{ steps.sanitised.outputs.name }}-trivy-report.json
        retention-days: 30

    - name: Register Scan Results as Action Output
      shell: sh
      id: generate-outputs
      run: |
        echo "scan-results=${{ steps.sanitised.outputs.name }}-trivy-report" >> $GITHUB_OUTPUT
        echo "scan-results-file=${{ steps.sanitised.outputs.name }}-trivy-report.json" >> $GITHUB_OUTPUT
        echo "scan-results-url=${{ steps.upload-scan-results.outputs.artifact-url }}" >> $GITHUB_OUTPUT

    - name: Get Report template
      uses: actions/checkout@v4
      with:
        repository: telicent-oss/trivy-action
        ref: main
        sparse-checkout: |
          report-template.tpl
        sparse-checkout-cone-mode: false
        path: .trivy-templates/

    - name: Fail build on High/Criticial Vulnerabilities
      id: gating-scan
      #uses: aquasecurity/trivy-action@0.30.0
      uses: rvesse/trivy-action@fix/overwrite-envs
      env:
        TRIVY_SKIP_DB_UPDATE: true
        TRIVY_SKIP_JAVA_DB_UPDATE: true
        TRIVY_SHOW_SUPPRESSED: true
      with:
        scan-type: ${{ inputs.scan-type }}
        format: template
        template: "@.trivy-templates/report-template.tpl"
        output: ${{ steps.sanitised.outputs.name }}-trivy-gating-report.txt
        scan-ref: ${{ inputs.scan-ref }}
        severity: HIGH,CRITICAL
        ignore-unfixed: ${{ inputs.allow-unfixed }}
        # Exit Code set to 1 so if any HIGH/CRITICAL vulnerabilities exist this step fails and the action fails
        exit-code: 1
        cache-dir: .trivy
        # We've explicitly called aquasecurity/setup-trivy already, no need for the trivy-action to do this for us
        skip-setup-trivy: true
        # Counter-intuitive BUT trivy-action has its own cache behaviour which duplicates our own but in a less 
        # flexible way
        cache: false

    - name: Display Gating Vulnerabilities in Job Summary (if any)
      if: ${{ always() }}
      shell: bash
      run: |
        if [ -f "${{ steps.sanitised.outputs.name }}-trivy-gating-report.txt" ]; then
          echo "# Trivy \`${{ inputs.scan-type }}\` scan on \` ${{inputs.scan-ref }}\`" >> "$GITHUB_STEP_SUMMARY"
          cat "${{ steps.sanitised.outputs.name }}-trivy-gating-report.txt" >> "$GITHUB_STEP_SUMMARY"
        fi

    - name: Add Error to Build if Scan Failed
      if: ${{ failure() && steps.gating-scan.outcome == 'failure' }}
      shell: sh
      run: |
        echo "::error title=${{ github.job }} - High/Critical Vulnerabilities Found::Trivy detected HIGH/CRITICAL vulnerabilities scanning ${{ inputs.scan-ref }}, please review the report and apply relevant fixes.  Report is attached as build artifact ${{ steps.sanitised.outputs.name }}-trivy-report and rendered as a human readable job summary."

    - name: Cleanup Merged VEX Statements
      if: ${{ always() }}
      shell: sh
      run: |
        rm -f ${{ steps.sanitised.outputs.name }}-merged.openvex.json
        rm -Rf .remote-vex/

    - name: Cleanup templates/
      if: ${{ always() }}
      shell: sh
      run: |
        rm -Rf .trivy-templates/
